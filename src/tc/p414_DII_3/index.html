<html>
<head>
    <title>Shape3D</title>


<link rel="stylesheet" href="../my_tc.css">

</head>
<body>
<h1><a href="http://community.topcoder.com/tc?module=ProblemDetail&amp;rd=13505&amp;pm=8394">Shape3D</a></h1>

<p><em>Single Round Match 414 Round 1 - Division II, Level Three</em></p>

<h2>Statement</h2>

<p>A shape in 3D Cartesian space is valid if it is made up of identical unit cubes, each cube in the shape has all its edges parallel to coordinate axes and its vertices are at non-negative integer coordinates. Two shapes are considered the same if one can be transformed into the other by some rotation and translation. You are given a description of a valid shape and should return the lexicographically smallest description of a valid shape that is the same as the one supplied.</p>

<p>You are given a String[] <em>shape</em>. Each element of <em>shape</em> describes a single unit cube from the shape and will contain three space-separated non-negative integers. The first of these gives the x-coordinate of the cube, the second gives the y-coordinate, and the third the z-coordinate. The cube is positioned such that the line segment between (x, y, z) and (x+1, y+1, z+1) is a diagonal of the cube and its edges are all parallel to the coordinate axes. Return a String[] containing the lexicographically smallest description of a valid shape in the same format as the input that can be transformed to the supplied shape by rotation and translation. Each element of your return must contain 3 single-space-separated non-negative integers without leading zeros and with no leading or trailing spaces. Each element of your return must describe a distinct cube from the shape.</p>

<h2>Definitions</h2>

<ul>
<li><em>Class</em>: <code>Shape3D</code></li>
<li><em>Method</em>: <code>findCanonical</code></li>
<li><em>Parameters</em>: <code>String[]</code></li>
<li><em>Returns</em>: <code>String[]</code></li>
<li><em>Method signature</em>: <code>String[] findCanonical(String[] shape)</code></li>
</ul>


<h2>Notes</h2>

<ul>
<li>The lexicographically earlier of two String[]s is the one that has the lexicographically earlier String in the first position at which they differ.</li>
<li>The lexicographically earlier of two Strings is the one that either has the earlier character (using ASCII ordering) at the first position at which they differ or is a proper prefix of the other.</li>
<li>In ASCII ordering, a space character (' ') comes before any digit.</li>
<li>The return will contain only digits ('0' - '9') and spaces (' ').</li>
<li>Since the cubes of any valid shape must be aligned with the coordinate axes, any valid rotation can be achieved by a sequence of 90 degree rotations around the coordinate axes.</li>
</ul>


<h2>Constraints</h2>

<ul>
<li><em>shape</em> will contain between 1 and 50 elements, inclusive.</li>
<li>Each element of <em>shape</em> will contain 3 space-separated integers without leading zeros between 0 and 1000, inclusive.</li>
<li>Each element of <em>shape</em> will contain no leading or trailing spaces.</li>
<li>The elements of <em>shape</em> will be distinct.</li>
<li>The cubes described in <em>shape</em> will form a connected volume in 3D Cartesian space, where 2 cubes are considered to be connected if they share a face.</li>
</ul>


<h2>Examples</h2>

<h3>Example 1</h3>

<h4>Input</h4>

<p><c>["0 0 0","1 0 0","1 1 0","1 1 1","1 0 1","0 1 1","0 0 1","0 1 0"]</c></p>

<h4>Output</h4>

<p><c>["0 0 0", "0 0 1", "0 1 0", "0 1 1", "1 0 0", "1 0 1", "1 1 0", "1 1 1" ]</c></p>

<h4>Reason</h4>

<p>This shape is a cube of side length 2, with a corner at the origin. No rotation or translation is required here, simply rearrange the order of the cubes to give the lexicographically minimum description.</p>

<h3>Example 2</h3>

<h4>Input</h4>

<p><c>["100 50 50","100 49 50","100 49 49"]</c></p>

<h4>Output</h4>

<p><c>["0 0 0", "0 0 1", "0 1 0" ]</c></p>

<h4>Reason</h4>

<p>This shape needs to be rotated and translated so one of the squares lies at the origin.</p>

<h3>Example 3</h3>

<h4>Input</h4>

<p><c>["11 11 11","10 11 11","12 11 11"<br />,"11 11 10","11 11 12","11 10 11"<br />,"11 12 11","9 11 11","13 11 11"]</c></p>

<h4>Output</h4>

<p><c>["0 1 1",<br />"1 1 1",<br />"2 0 1",<br />"2 1 0",<br />"2 1 1",<br />"2 1 2",<br />"2 2 1",<br />"3 1 1",<br />"4 1 1" ]</c></p>

<h3>Example 4</h3>

<h4>Input</h4>

<p><c>["100 900 800","101 900 800","102 900 800","102 899 800"<br />,"102 898 800","102 897 800","102 896 800","102 896 801"<br />,"102 896 802","102 896 803","102 896 804","102 896 805"<br />,"102 896 806","102 896 807","102 896 808"]</c></p>

<h4>Output</h4>

<p><c>["0 0 0",<br />"0 0 1",<br />"0 0 2",<br />"0 0 3",<br />"0 0 4",<br />"0 0 5",<br />"0 0 6",<br />"0 0 7",<br />"0 0 8",<br />"0 1 8",<br />"0 2 8",<br />"0 3 8",<br />"0 4 8",<br />"1 4 8",<br />"2 4 8" ]</c></p>

<h3>Example 5</h3>

<h4>Input</h4>

<p><c>["2 2 0","2 2 1","2 2 3","2 2 4","2 0 2","2 1 2","2 3 2","2 4 2","0 2 2","1 2 2","3 2 2","4 2 2","2 2 2"]`</c></p>

<h4>Output</h4>

<p><c>["0 10 10",<br />"1 10 10",<br />"2 10 10",<br />"2 10 11",<br />"2 10 12",<br />"2 10 8",<br />"2 10 9",<br />"2 11 10",<br />"2 12 10",<br />"2 8 10",<br />"2 9 10",<br />"3 10 10",<br />"4 10 10" ]</c></p>

<h4>Reason</h4>

<p>Be careful! Lexicographic ordering is not the same as numerical ordering.</p>

</body>
</html>